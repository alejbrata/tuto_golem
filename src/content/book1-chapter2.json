{
    "id": "1-2",
    "es": {
        "title": "La Brújula Semántica",
        "lore": "Has fragmentado el alma en tokens, pero ahora yacen como polvo inerte en el suelo de la torre. Para que el Golem piense, debe entender el *sentido* detrás de los símbolos. Debes otorgarle una **Brújula Semántica**. En el reino de las máquinas, el significado no es una definición de diccionario, sino una coordenada en un mapa de infinitas dimensiones. Dos conceptos son 'amigos' si caminan juntos en este espacio matemático.",
        "lesson": "Las palabras se convierten en números, pero no números aleatorios. Se convierten en **Embeddings** (Vectores).\n\nImagina un mapa 2D donde el eje X es 'Fuerza Física' y el eje Y es 'Poder Mágico'.\n- Un **'Guerrero'** tendría coordenadas altas en Fuerza y bajas en Magia: `[0.9, 0.1]`\n- Un **'Mago'** sería lo opuesto: `[0.1, 0.9]`\n- Un **'Paladín'** estaría en medio: `[0.6, 0.6]`\n\nPara saber qué tan similares son dos almas (vectores), usamos el **Producto Escalar**. Si los vectores fueran flechas de longitud 1, esto es equivalente a medir el ángulo entre ellas.\n- Si apuntan al mismo sitio, su producto es 1 (Máxima similitud).\n- Si son perpendiculares, es 0.\n\nTu misión: Enseñar al Golem a calcular la afinidad entre dos esencias.",
        "hints": [
            "El Producto Escalar es suma de multiplicaciones: `(x1*x2) + (y1*y2)`.",
            "Multiplica `vec1[0]` por `vec2[0]`.",
            "Súmalo a la multiplicación de `vec1[1]` por `vec2[1]`.",
            "Retorna el resultado."
        ],
        "initialCode": "# Esencias de prueba (Vectores [Fuerza, Magia])\n# Imagina que estas listas son coordenadas en el mapa del alma\nalma_guerrero = [0.9, 0.1]\nalma_paladin =  [0.6, 0.6]\n\ndef calcular_proximidad(vec1, vec2):\n    # El Producto Escalar es la suma de las multiplicaciones de sus coordenadas:\n    # Fórmula: (x1 * x2) + (y1 * y2)\n    \n    # <--- TU ALQUIMIA AQUÍ:\n    # Implementa la fórmula matemática\n    resultado = 0\n    return resultado\n\n# Invocación de prueba\nafinidad = calcular_proximidad(alma_guerrero, alma_paladin)\n\nprint(f\"Afinidad entre Guerrero y Paladín: {afinidad}\")"
    },
    "en": {
        "title": "The Semantic Compass",
        "lore": "You have fragmented the soul into tokens, but now they lie as inert dust on the tower floor. For the Golem to think, it must understand the *meaning* behind the symbols. You must grant it a **Semantic Compass**. In the realm of machines, meaning is not a dictionary definition, but a coordinate on a map of infinite dimensions. Two concepts are 'friends' if they walk together in this mathematical space.",
        "lesson": "Words become numbers, but not random numbers. They become **Embeddings** (Vectors).\n\nImagine a 2D map where the X-axis is 'Physical Strength' and the Y-axis is 'Magic Power'.\n- A **'Warrior'** would have high Strength and low Magic coordinates: `[0.9, 0.1]`\n- A **'Wizard'** would be the opposite: `[0.1, 0.9]`\n- A **'Paladin'** would be in between: `[0.6, 0.6]`\n\nTo know how similar two souls (vectors) are, we use the **Dot Product**. If vectors were arrows of length 1, this is equivalent to measuring the angle between them.\n- If they point to the same place, their product is 1 (Maximum similarity).\n- If they are perpendicular, it is 0.\n\nYour mission: Teach the Golem to calculate the affinity between two essences.",
        "hints": [
            "The Dot Product is the sum of multiplications: `(x1*x2) + (y1*y2)`.",
            "Multiply `vec1[0]` by `vec2[0]`.",
            "Add it to the multiplication of `vec1[1]` by `vec2[1]`.",
            "Return the result."
        ],
        "initialCode": "# Test Essences (Vectors [Strength, Magic])\n# Imagine these lists are coordinates on the soul map\nsoul_warrior = [0.9, 0.1]\nsoul_paladin =  [0.6, 0.6]\n\ndef calcular_proximidad(vec1, vec2):\n    # The Dot Product is the sum of the multiplications of their coordinates:\n    # Formula: (x1 * x2) + (y1 * y2)\n    \n    # <--- YOUR ALCHEMY HERE:\n    # Implement the mathematical formula\n    resultado = 0\n    return resultado\n\n# Test Invocation\nafinidad = calcular_proximidad(soul_warrior, soul_paladin)\n\nprint(f\"Affinity between Warrior and Paladin: {afinidad}\")"
    },
    "solutionCode": "# Esencias de prueba (Vectores [Fuerza, Magia])\nalma_guerrero = [0.9, 0.1]\nalma_paladin =  [0.6, 0.6]\n\ndef calcular_proximidad(vec1, vec2):\n    # Producto Escalar: (x1*x2) + (y1*y2)\n    return (vec1[0] * vec2[0]) + (vec1[1] * vec2[1])\n\n# Invocación de prueba\nafinidad = calcular_proximidad(alma_guerrero, alma_paladin)\n\nprint(f\"Afinidad entre Guerrero y Paladín: {afinidad}\")",
    "validationCode": "\ndef validar_mision(globals_dict):\n    try:\n        if 'calcular_proximidad' not in globals_dict:\n            return False, \"¡La brújula no está forjada! Define la función 'calcular_proximidad'.\"\n        \n        calc_func = globals_dict['calcular_proximidad']\n        \n        # Test Case 1: Orthogonal (Different)\n        v1 = [1, 0]\n        v2 = [0, 1]\n        if calc_func(v1, v2) != 0:\n             return False, \"La lógica falla con rumbos opuestos. (1*0 + 0*1) debería ser 0.\"\n\n        # Test Case 2: Warrior vs Paladin verification\n        # Expected: 0.9*0.6 + 0.1*0.6 = 0.54 + 0.06 = 0.6\n        user_val = calc_func([0.9, 0.1], [0.6, 0.6])\n        if abs(user_val - 0.6) > 0.001:\n             return False, f\"Tu cálculo dio {user_val}, pero para Guerrero y Paladín esperábamos 0.6.\"\n\n        return True, \"¡La brújula vibra! El Golem ahora percibe la dirección de las almas.\"\n    except Exception as e:\n        return False, f\"Error mágico: {str(e)}\"\n"
}