{
    "id": "1-2",
    "title": "La Brújula Semántica",
    "lore": "Has fragmentado el alma en tokens, pero ahora yacen como polvo inerte en el suelo de la torre. Para que el Golem piense, debe entender el *sentido* detrás de los símbolos. Debes otorgarle una **Brújula Semántica**. En el reino de las máquinas, el significado no es una definición de diccionario, sino una coordenada en un mapa de infinitas dimensiones. Dos conceptos son 'amigos' si caminan juntos en este espacio matemático.",
    "lesson": "Las palabras se convierten en números, pero no números aleatorios. Se convierten en **Embeddings** (Vectores).\n\nImagina un mapa 2D donde el eje X es 'Fuerza Física' y el eje Y es 'Poder Mágico'.\n- Un **'Guerrero'** tendría coordenadas altas en Fuerza y bajas en Magia: `[0.9, 0.1]`\n- Un **'Mago'** sería lo opuesto: `[0.1, 0.9]`\n- Un **'Paladín'** estaría en medio: `[0.6, 0.6]`\n\nPara saber qué tan similares son dos almas (vectores), usamos el **Producto Escalar**. Si los vectores fueran flechas de longitud 1, esto es equivalente a medir el ángulo entre ellas.\n- Si apuntan al mismo sitio, su producto es 1 (Máxima similitud).\n- Si son perpendiculares, es 0.\n\nTu misión: Enseñar al Golem a calcular la afinidad entre dos esencias.",
    "initialCode": "# Esencias de prueba (Vectores [Fuerza, Magia])\n# Imagina que estas listas son coordenadas en el mapa del alma\nalma_guerrero = [0.9, 0.1]\nalma_paladin =  [0.6, 0.6]\n\ndef calcular_proximidad(vec1, vec2):\n    # El Producto Escalar es la suma de las multiplicaciones de sus coordenadas:\n    # (x1 * x2) + (y1 * y2)\n    # <--- TU ALQUIMIA AQUÍ\n    resultado = 0\n    return resultado\n\n# Invocación de prueba\nafinidad = calcular_proximidad(alma_guerrero, alma_paladin)\n\nprint(f\"Afinidad entre Guerrero y Paladín: {afinidad}\")",
    "hints": [
        "Multiplica `vec1[0]` por `vec2[0]`.",
        "Súmalo a la multiplicación de `vec1[1]` por `vec2[1]`.",
        "No necesitas `import`, es pura matemática básica."
    ],
    "solutionCode": "# Esencias de prueba (Vectores [Fuerza, Magia])\nalma_guerrero = [0.9, 0.1]\nalma_paladin =  [0.6, 0.6]\n\ndef calcular_proximidad(vec1, vec2):\n    # Producto Escalar: (x1*x2) + (y1*y2)\n    return (vec1[0] * vec2[0]) + (vec1[1] * vec2[1])\n\n# Invocación de prueba\nafinidad = calcular_proximidad(alma_guerrero, alma_paladin)\n\nprint(f\"Afinidad entre Guerrero y Paladín: {afinidad}\")",
    "validationCode": "\ndef validar_mision(globals_dict):\n    try:\n        if 'calcular_proximidad' not in globals_dict:\n            return False, \"¡La brújula no está forjada! Define la función 'calcular_proximidad'.\"\n        \n        calc_func = globals_dict['calcular_proximidad']\n        \n        # Test Case 1: Orthogonal (Different)\n        v1 = [1, 0]\n        v2 = [0, 1]\n        if calc_func(v1, v2) != 0:\n             return False, \"La lógica falla con rumbos opuestos. (1*0 + 0*1) debería ser 0.\"\n\n        # Test Case 2: Warrior vs Paladin verification\n        # Expected: 0.9*0.6 + 0.1*0.6 = 0.54 + 0.06 = 0.6\n        user_val = calc_func([0.9, 0.1], [0.6, 0.6])\n        if abs(user_val - 0.6) > 0.001:\n             return False, f\"Tu cálculo dio {user_val}, pero para Guerrero y Paladín esperábamos 0.6.\"\n\n        return True, \"¡La brújula vibra! El Golem ahora percibe la dirección de las almas.\"\n    except Exception as e:\n        return False, f\"Error mágico: {str(e)}\"\n"
}