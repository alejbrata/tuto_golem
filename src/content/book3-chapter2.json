{
    "id": "3-2",
    "es": {
        "title": "Cadenas de Mando",
        "lore": "El Golem debe enviar un mensaje vital al Reino de los Enanos. Pero no es tan simple. El mensaje debe ser: 1. Traducido a Runas Antiguas, 2. Resumido para caber en la garra de un cuervo mecánico, y 3. Encriptado con magia de sombra. Si haces esto mano a mano, tardarás siglos. Debes forjar una 'Cadena de Mando' automática donde la salida de un hechizo sea la entrada del siguiente.",
        "lesson": "En la Alquimia Avanzada (LangChain), no invocamos al LLM uan sola vez. Creamos **Cadenas (Chains)**.\n\nUna cadena conecta eslabones:\n`Input -> [Paso 1: Traducir] -> [Paso 2: Resumir] -> [Paso 3: Encriptar] -> Output`\n\nTu misión: Conectar estos 3 módulos. Asegúrate de que los datos fluyan sin romperse. Si un eslabón falla, toda la cadena se congela.",
        "hints": [
            "Paso 2.1: Ejecuta `r1 = paso1.run(mensaje_original)`.",
            "Paso 2.2: Pasa el resultado al siguiente: `r2 = paso2.run(r1)`.",
            "Paso 2.3: Y al último: `resultado_final = paso3.run(r2)`.",
            "¡El orden importa! Traductor -> Resumidor -> Encriptador."
        ],
        "initialCode": "mensaje_original = \"Saludos, noble Rey de la Montaña. Necesitamos 500 lingotes de mitril para reparar la Torre Este antes del amanecer.\"\n\nclass ChainStep:\n    def __init__(self, name, logic):\n        self.name = name\n        self.logic = logic\n    \n    def run(self, input_text):\n        print(f\"[{self.name}] Procesando: {input_text}...\")\n        return self.logic(input_text)\n\n# Lógica de los eslabones (Simulada)\ndef traducir(txt): return f\"RUNAS({txt})\"\ndef resumir(txt): return txt.replace(\"Saludos, noble Rey de la Montaña. \", \"\").replace(\" para reparar la Torre Este antes del amanecer\", \"\")\ndef encriptar(txt): return f\"%%%{txt[::-1]}%%%\"\n\n# 1. Define los Eslabones\npaso1 = ChainStep(\"Traductor\", traducir)\npaso2 = ChainStep(\"Resumidor\", resumir)\npaso3 = ChainStep(\"Encriptador\", encriptar)\n\n# 2. Crea la Cadena (SequentialChain)\n# <--- TU CÓDIGO AQUÍ: Conecta paso1 -> paso2 -> paso3\n# r1 = paso1.run(mensaje_original)\nr1 = None\n# r2 = ...\n# resultado_final = ...\nresultado_final = None\n\n# print(f\"Mensaje Final para el Cuervo: {resultado_final}\")"
    },
    "en": {
        "title": "Chains of Command",
        "lore": "The Golem must send a vital message to the Kingdom of Dwarves. But it is not that simple. The message must be: 1. Translated into Ancient Runes, 2. Summarized to fit in the claw of a mechanical raven, and 3. Encrypted with shadow magic. If you do this by hand, it will take centuries. You must forge an automatic 'Chain of Command' where the output of one spell is the input of the next.",
        "lesson": "In Advanced Alchemy (LangChain), we don't summon the LLM just once. We create **Chains**.\n\nA chain connects links:\n`Input -> [Step 1: Translate] -> [Step 2: Summarize] -> [Step 3: Encrypt] -> Output`\n\nYour mission: Connect these 3 modules. Ensure data flows without breaking. If one link fails, the entire chain freezes.",
        "hints": [
            "Step 2.1: Execute `r1 = paso1.run(mensaje_original)`.",
            "Step 2.2: Pass the result to the next: `r2 = paso2.run(r1)`.",
            "Step 2.3: And to the last: `resultado_final = paso3.run(r2)`.",
            "The order matters! Translator -> Summarizer -> Encryptor."
        ],
        "initialCode": "mensaje_original = \"Greetings, noble Mountain King. We need 500 mithril ingots to repair the East Tower before dawn.\"\n\nclass ChainStep:\n    def __init__(self, name, logic):\n        self.name = name\n        self.logic = logic\n    \n    def run(self, input_text):\n        print(f\"[{self.name}] Processing: {input_text}...\")\n        return self.logic(input_text)\n\n# Link Logic (Simulated)\ndef traducir(txt): return f\"RUNES({txt})\"\ndef resumir(txt): return txt.replace(\"Greetings, noble Mountain King. \", \"\").replace(\" to repair the East Tower before dawn\", \"\")\ndef encriptar(txt): return f\"%%%{txt[::-1]}%%%\"\n\n# 1. Define the Links\npaso1 = ChainStep(\"Translator\", traducir)\npaso2 = ChainStep(\"Summarizer\", resumir)\npaso3 = ChainStep(\"Encryptor\", encriptar)\n\n# 2. Create the Chain (SequentialChain)\n# <--- YOUR CODE HERE: Connect paso1 -> paso2 -> paso3\n# r1 = paso1.run(mensaje_original)\nr1 = None\n# r2 = ...\n# resultado_final = ...\nresultado_final = None\n\n# print(f\"Final Message for the Raven: {resultado_final}\")"
    },
    "solutionCode": "mensaje_original = \"Saludos, noble Rey de la Montaña. Necesitamos 500 lingotes de mitril para reparar la Torre Este antes del amanecer.\"\n\nclass ChainStep:\n    def __init__(self, name, logic):\n        self.name = name\n        self.logic = logic\n    \n    def run(self, input_text):\n        print(f\"[{self.name}] Procesando... \")\n        return self.logic(input_text)\n\n# Definir funciones\ndef traducir(txt): return f\"RUNAS: {txt}\"\ndef resumir(txt): return \"Necesitamos 500 mitril.\"\ndef encriptar(txt): return f\"%%%{txt[::-1]}%%%\"\n\n# Instanciar pasos\npaso1 = ChainStep(\"Traductor\", traducir)\npaso2 = ChainStep(\"Resumidor\", resumir)\npaso3 = ChainStep(\"Encriptador\", encriptar)\n\n# Ejecución en Cadena (Pipeline)\nr1 = paso1.run(mensaje_original)\nr2 = paso2.run(r1)\nresultado_final = paso3.run(r2)\n\nprint(f\"Mensaje Final: {resultado_final}\")",
    "validationCode": "\ndef validar_mision(globals_dict):\n    try:\n        if 'resultado_final' not in globals_dict:\n            return False, \"La cadena se rompió. No existe 'resultado_final'.\"\n        \n        res = globals_dict['resultado_final']\n        if not isinstance(res, str):\n            return False, \"El resultado de la cadena debe ser texto.\"\n            \n        # Check encryption (reversed string markers %%%)\n        if not res.startswith(\"%%%\") or not res.endswith(\"%%%\"):\n            return False, \"El mensaje no está encriptado con magia de sombra (%%%). Revisa el paso 3.\"\n            \n        # Check summary content (reversed 'mitril')\n        if \"lirtim\" not in res.lower() and \"sanuR\" not in res[::-1]: \n             # 'Runas' backwards is 'sanuR'\n            return False, \"El mensaje no parece contener la información correcta. ¿Conectaste los pasos en orden?\"\n\n        return True, \"¡Cadena Forjada! El mensaje fluye a través de los eslabones perfectamente.\"\n    except Exception as e:\n        return False, f\"Fallo catastrófico en la cadena: {str(e)}\"\n"
}